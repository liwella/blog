---
title: 可扩展系统架构设计原则
author: 青蛙瓷器
img: 'http://pic.tanzhang.work/blog/gallary/221205.jpg!up.webp'
top: true
cover: false
toc: true
mathjax: false
categories: 分布式
tags:
  - 架构
  - 设计
abbrlink: 1ec5c01e
date: 2022-12-05 22:07:49
coverImg:
---
软件工程和建筑工程最大的不同在于，建筑在落成以后，其形状和功能就已基本固定，不会再有太多修改；而软件却会因为需求的变化，导致其在开发完成后，依然需要不停的进行迭代和修改。这并不意味着软件是天然就很方便的支持修改和扩展的，良好的设计是保证扩展性的前提。设计良好的软件可以很方便的进行修改和扩展，可以将修改对系统的影响降至最低；设计糟糕的软件在修改时则很容易产生问题，牵一发而动全身，甚至导致整个系统崩溃。因此，掌握可扩展性架构设计对研发人员来说也是重中之重的。

## 可扩展架构设计的分类

可扩展架构设计的方法很多，但其背后的基本思想都可以总结为一个字：拆！通过合理的拆解软件系统，使其具备更好的扩展性。按照不同的拆分思路，可以得到不同的架构。常见的拆分方式有以下三种：

1. 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分；
2. 面向服务拆分：按系统提供的服务进行拆分，每个服务作为一部分；
3. 面向功能拆分：按系统提供的功能进行拆分，每个功能作为一部分；

这三种拆分方式并非是非此即彼的，例如一个商城系统，按照服务可以将它拆分为用户服务、商品服务、订单服务等。在更细粒度上，又可以再按照功能进行拆分，例如用户服务中的登录功能可以拆分为手机号登录、微信登录、邮箱登录等。每个服务又按照代码执行流程进行拆分，将服务拆分为展示层 、业务层、数据层和存储层。
![商城系统按照不同方式拆分结果](http://pic.tanzhang.work/blog/extension_design.png!up.webp)

这三种拆分方式再应对修改和扩展时都有其独到的优势，具体体现如下：

- 面向流程拆分：大部分情况下修改都只会影响到某一层，不会影响到其他层；
- 面向服务拆分：当需要扩展服务时，只需要新增对应服务即可；当需要修改某个服务时，也只需对应修改即可；
- 面向功能拆分：对某个功能进行扩展或新增某个功能时，只需要扩展相关功能即可；

按照不同的拆分方式，还会得到不同的系统架构，典型的可扩展系统架构如下：

- 面向流程拆分：分层架构
- 面向服务拆分：SOA、微服务架构
- 面向功能拆分：微内核架构

## 分层架构

按照不同的维度对流程进行拆分，可以得到不同的分层架构。

- **C/S、B/S 架构**：c/s、b/s架构的对象是整个系统，划分依据为用户的交互方式，将和用户交互的部分独立为一层，而支撑用户交互的后台作为另外一层；
- **MVC、MVP架构**：划分的对象是单个业务子系统，划分维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如 MVC 架构中的层是两两交互的；

![MVC分层架构](http://pic.tanzhang.work/blog/MVC.png!up.webp)

- **逻辑分层架构**：逻辑分层架构的划分对象可以是整个系统，也可以是单个业务子系统；划分维度也是职责，但跟 MVC、MVP 架构不同的是，逻辑分层架构中的层是自顶向下依赖的，例如典型的 J2EE 系统架构，将系统划分为 展示层、业务层、持久层和数据库层；

### 分层架构的特点

分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，这也是分层不能太多的原因，防止层与层之间的差异不明显造成歧义。

分层架构之所以能较好的支撑扩展系统，本质在于 **隔离关注点**。每个层只会处理本层的逻辑，当需要扩展或修改某层时，其他层时不受影响的。

当然，并不是只需要简单的分层就一定能实现隔离关注点从而支撑快速扩展，分层之间的**依赖也需要是稳定的**，才能支撑快速扩展。接口层的作用就是用来保证层与层之间依赖的稳定性，当下层发生扩展或修改时，上层依赖的是稳定的接口层，不会受到影响；
![通过稳定的接口层来隔离变化](http://pic.tanzhang.work/blog/stable_interfaceinterface.png!up.webp)

分层架构的另一个特点是 **层层传递**，整个业务流程是按照层进行以此传递的，不能在层之间跳跃。这种好处在于强制将依赖限定为两两依赖，降低了系统的整体复杂度。

### 分层架构的缺点

分层架构的缺点之一就是 **冗余**，不管业务有多简单，每层都必须参与处理，甚至有些层就仅仅是一个简单的包装处理。不过尽管冗余，依然不建议在开发时绕过分层的约束，一旦选择绕过分层，时间一长，架构就会变得混乱，后续扩展时的影响也无法得到控制。

分层架构的另一个缺点就是 **性能**，由于每次请求都会穿过所有的分层，有一些处理时多余的，多少会产生一些性能浪费；

## SOA架构

SOA 架构主要用来解决 传统 IT 系统重复建设和扩展效率低下的问题。这里的 IT 系统不是单独的某个系统，而是企业内部的 IT 门户系统的统称，比如 人力资源系统，财务系统，销售系统等，统称为 IT 系统。

由于企业内部的 IT 系统不是采购于一家公司，所以其技术实现通常会有所差异。例如人力资源系统使用 Java 开发，对外提供的接口协议是 RPC 协议，而销售系统用 C# 开发，对外提供 SOAP 协议。由于使用不同的协议，二者通信是一件比较困难的事情，每次有相关的功能需要开发，都需要对二者进行协同，同时定制开发，效率较低。

### SOA特点

为了解决传统 IT 系统存在的问题，SOA 提出了三个关键概念。

1. **服务**：所有业务功能都是一项服务，需要对外提供开放的能力，当其他系统需要使用这项功能时，无需定制化开发；
2. **ESB**：ESB（Enterprise Service Bus）企业服务总线，将所有服务连接在一起。其作用就是解决异构服务间的通信问题，屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务简单互联互通；
3. **松耦合**：松耦合的目的时减少服务简单依赖和互相影响，防止某个服务的故障影响其他服务。

典型的 SOA 架构如下图所示：
![SOA架构组成](http://pic.tanzhang.work/blog/SOA.png!up.webp)

SOA 架构是一种比较高层级的设计理念，通常用来解决多个系统之间的异构问题，而不会在某个单独的系统上使用 SOA 架构。例如某个企业在解决内部的人力资源管理系统、财务管理系统以及其他一些系统通信问题时采用了 SOA 的架构方式，而不是某个企业的人力资源管理系统采用了SOA 的架构方式。

### SOA缺点

SOA解决了传统 IT 系统的重复建设和扩展效率低问题，但其也引入了其他问题，这写问题基本都体现在 ESB 上。ESB 需要实现各种系统间协议的转换、数据的转换、透明的动态路由等，这就导致 ESB 本身需要做的事情太多，工作量和复杂度都很大，当 ESB 承载的工作太多时，其本身也会成为整个系统的瓶颈。

## 微服务

微服务和 SOA 的概念中都包含了“服务”，但二者并不是同一个事物，具体区别如下：

| 对比维度 |     SOA     |          微服务          |
| :------: | :---------: | :-----------------------: |
| 服务粒度 |     粗     |            细            |
| 服务通信 | 重量级，ESB | 轻量级，例如 HTTP Restful |
| 服务交付 |     慢     |            快            |
| 应用场景 |   企业级   |          互联网          |

微服务和 SOA 是两种相似但本质上不同的架构理念，其不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度和架构设计的目标等。微服务强调 small、lightweight、automated。

微服务和 SOA 并不存在孰优孰劣，只是二者的应用场景不同，对于庞大、复杂、异构的企业级系统，业务上又要求其互通时，采用 SOA 架构更加合适，而微服务更加适合业务变化快，需要快速尝试、快速交付的场景。

### 微服务的陷阱

微服务并非架构灵药，当使用不当时，可能会产生如下问题：

- 服务划分过细，服务间关系复杂；
- 服务数量太多，团队效率急剧下降；
- 调用链太长，性能下降
- 调用链太长，定位问题困难；
- 没有服务治理，服务数量多了以后管理混乱；
- 没有自动化支撑，无法快速交付；

上述问题的产生从本质上来讲可以归纳为以下几点：

- 微服务拆分过细，过分强调“small”；
- 微服务基础设施不健全，忽略了“automated”；
- 微服务并不轻量级，规模大了以后，“lightweight”不再适用；

### 微服务最佳实践

#### 服务粒度

**三个火枪手原则**：针对微服务拆分过细的问题，建议基于团队规模拆分，在服务设计和开发阶段，一般 **3个人** 为一个小组对一个服务进行开发，3个人开发正好能保证每个人都能全面理解整个系统，充分的展现自己的技术实力；且3个人可以形成一个稳定的备份，防止其中有一人调动时剩余人员压力过大的问题。

当服务经过一段时间的发展后处于稳定的维护状态了，则可以将服务交予一人维护，甚至一个人可以维护多个微服务都可以；

#### 拆分方法

微服务常见的拆分方法有以下几种：

1. 基于业务拆分：将系统中的业务模块按照职责范围划分开来，每个独立的业务模块拆分为一个独立的服务。具体拆分的时候需要先根据“三个火枪手”原则，确定以下服务的数量，然后再根据服务数量以及职责范围对服务进行划分，防止拆分过粗或过细；
2. 基于可扩展拆分：将系统中的业务模块按照稳定性进行排序，将成熟和稳定的业务拆分为稳定服务，将经常变化和迭代的业务拆分为变动服务。稳定服务的粒度可以粗一些，不稳定服务的粒度可以细一些，但不能太细，防止服务数量过多。
   这样拆分的好处是可以提升项目迭代效率，并且防止开发时影响到已有的成熟功能导致线上问题。
3. 基于可靠性拆分：将系统中的可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，重点保证核心服务的高可用，这样拆分可以带来以下几个好处：
   1. 避免非核心服务故障影响核心服务；
   2. 核心服务高可用方案可以更简单；
   3. 降低高可用成本；
4. 基于性能拆分：根据性能拆分和根据可靠性拆分类似，将性能压力大的服务拆分出来作为独立服务，避免影响其他服务。

#### 基础设施

正真决定微服务成败的，是 automated——自动治理，微服务通过各种基础设施来实现服务的自动治理，常见的基础设施如下图所示：
![微服务基础设施](http://pic.tanzhang.work/blog/micro_service.png!up.webp)

微服务的基础设施并不在少数，其庞大程度加起来甚至远超 ESB。实际上微服务之所以被称为轻量级，就是因为其复杂度从 SOA 的 ESB 转移到了基础设施，而服务本身是相对“轻量级”的，开发者可以更加聚焦于业务的开发。

不过，虽然微服务的基础设施有很多，但并不是所有都是必须的，通常情况下，可以按照以下优先级来搭建基础设施：

1. 服务发现、服务路由、服务容错：这是最基本的微服务基础设施；
2. 接口框架、API 网关：可以提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率；
3. 自动化部署、自动化测试、配置中心：用于提升测试和运维效率。
4. 服务监控、服务跟踪、服务安全：用于进一步提升运维效率。

以上 3 和 4 两类基础设施，其重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑，虽然效率不高，但也基本能够顶住。

## 微内核架构

微内核架构也称为插件化架构，是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。例如QQ，微信等客户端平台，可以通过添加各种插件来增加其功能。

微内核架构主要包含两类组件：

- 核心系统：负责和具体业务功能无关的通用功能，如模块加载，模块间通信等；
- 插件模块：负责实现具体的业务逻辑；

微内核架构的基本示意图如下：
![微内核架构](http://pic.tanzhang.work/blog/micro_core.png!up.webp)

微内核架构的核心系统比较稳定，不会因为业务功能的扩展而不断修改；插件模块可以根据业务的变化而不断扩展。

### 微内核架构的关键点

微内核的核心系统设计的关键技术有以下几部分：

- 插件管理：核心系统可以通过插件注册表来实现插件管理，包括识别插件名字，位置以及加载时间等；
- 插件连接：指插件如何连接到核心系统，核心系统需要定制插件的连接规范，插件需要按照规范进行实现，才能正确接入到核心系统；常见的插件连接机制有：OSGi、消息模式、依赖注入等；
- 插件通信：虽然插件间是解耦的，但实际业务运行过程中必然会涉及到多个插件之间的协作，这就要求插件之间能够通信。核心系统需要提供插件之间的通信机制，保证插件间的正常通信。

### OSGi架构

OSGi是一个插件化的标准，而不是一个可运行的框架，常见的基于 OSGi 标准设计的框架有 Equinox、Felix 以及 Spring DM 等。OSGi 具备动态化、热插拔、高可复用性、高效性、扩展方便等优点。OSGi 标准定义的逻辑架构图如下所示：
![OSGi逻辑架构图](http://pic.tanzhang.work/blog/OSGi.png!up.webp)

从图可知 OSGi 定义的架构主要包含以下三部分：

- 模块层：模块层负责完成插件管理功能。OSGi 中的插件被称为 Bundle，每个 Bundle 都是一个 jar 文件，其中的 MANIFEST.MF 文件包含了插件的基本信息，核心系统通过这些信息识别并加载插件；
- 生命周期层：完成插件连接功能。生命周期层定义了 bundle 生命周期的操作（安装、更新、启动、停止、卸载），Bundle 需要按照规范来实现各个操作；
- 服务层：实现插件通信功能。服务层提供了服务注册功能，插件可以注册到服务注册中心上，供其他服务调用。

### 规则引擎架构

规则引擎从结构上来看也属于微内核架构的一种，其中执行引擎可以看作核心系统，而各种规则可以理解为插件模块。执行引擎通过解析配置好的业务流，执行其中的条件和规则，来支持业务的灵活多变。

规则引擎在计费、保险、促销等业务领域应用较多，目前最常用的规则引擎是开源的 JBoss Drools。

## 总结

软件需求的变化是日新月异的，这也为软件的扩展性带了极大的挑战，为了应对扩展与变化，诞生了各种不同的架构方式：分层架构、SOA 架构、微服务架构和微内核架构等，这些架构方式并非是非此及彼的，只有理解了各种可扩展架构模式的优缺点，适用场景，才能在做可扩展架构时做到合理的应用。
