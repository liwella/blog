---
title: redis分布式锁
date: 2022-11-20 10:19:00
author: 青蛙瓷器
img: http://pic.tanzhang.work/blog/gallary/221120.jpg
top: false
cover: false
coverImg: 
toc: true
mathjax: false
categories: redis
tags:
  - 分布式锁
  - redission
---
线程可以共享进程范围内的资源，如内存句柄和文件句柄等，这并不意味着进程的所有资源都是共享的，每个线程有各自的程序计数器，栈以及局部变量等。线程提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，以提高复杂应用程序的性能。但是，由于线程可以共享进程的内存地址空间，如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程在访问某个变量时，另一个线程可能同时访问这个变量，造成不可预测的结果。

## 线程安全的影响因素

影响线程安全的因素包括 **原子性、可见性和有序性。**

### 原子性

线程安全性是非常复杂的，在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果，如下所示程序就可能会产生线程安全性问题：

```java
public class UnsafeSequence {
	private int value;
	// 每次调用都返回一个唯一的数值
	public int getNext() {
		return value++;
	}
}
```

在多线程环境下，上述程序并不能保证每次调用都获取到唯一的值。其原因在于 value++ 并非是原子的操作，可以将它分解为：读取 value，将 value 加 1，并将结果写入到 value。当有两个线程同时执行读取操作的时候，该方法就会得到相同的结果。

### 可见性

在处理运算任务时，计算机处理器需要与内存进行交互，如读取运算数据、存储运算结果等，这个 io 操作时很难消除的（无法仅靠寄存器来完成所有的运算任务）。由于处理器的运算速度与内存之间有着几个数量级的差距，如果处理器直接对内存进行读写，会拖慢处理器的运算速度。现代计算机系统为了解决这个问题，引入了一层或多层接近处理器运算速度的高速缓存来作为处理器和内存之间的缓冲。处理器在进行运算时，将需要使用的数据复制到高速缓存中，进行运算处理，处理完成后再从缓存中同步回内存中，这样就不需要等待缓慢的内存读写了。

基于高速缓存的存储交互很好的解决了处理器与内存之间速度的矛盾。

单线程环境下，一个线程先向某个变量写入值，然后在不写入其他值的情况下再读取这个值，总能得到相同的结果。这听起来像是一句废话，但是在多线程环境下，这个结论却并不一定成立：一个线程先向某个变量写入一个值，随后另一个线程读取这个变量，所得到的结果并不一定和上一个线程写入的相同，这时就产生了线程安全种的可见性问题。


### 有序性
