---
title: 分布式事务基础理论
date: 2022-12-27 21:50:41
author: 青蛙瓷器
img: http://pic.tanzhang.work/blog/gallary/221223.jpg
top: false
cover: false
coverImg: 
toc: true
mathjax: false
categories: 分布式
tags:
  - 事务
---
微服务的出现解决了单体架构的痛点和难点，同时也引入了一些新的问题，服务如何治理、通信、服务划分以及服务间数据的一致性等等，都会影响到微服务架构的成败。本节讨论的是如何在微服务架构下依然保证各服务间数据的一致性，在单数据源的情况下，我们可以依托数据库提供的事务能力来保证一致性，但微服务场景下存在多个数据源，当业务请求需要同时更新或修改多个数据源的数据时，如何保证这些数据同时修改成功或失败，就成了一个需要关注的问题。为了解决这个问题，诞生了很多基础理论，如 CAP定理、BASE 理论，以及 2PC、3PC 等强一致性事务理论。

## CAP 定理

CAP 是 Consistency 一致性、Availability 可用性、Partition Tolarance  分区容忍性 三者的缩写。

- 一致性：指在分布式系统中任何时候所获取到的数据都是符合预期的；
- 可用性：任何时刻非故障的节点都能在合理时间内返回响应；
- 分区容忍性：表示分布式系统出现 **网络分区** 后，依然能够继续提供服务；

CAP 定理指出在任何时候，一个涉及共享数据的分布式系统最多只能同时满足一致性、可用性和分区容忍性中的二者，即满足 CP、AP 或者 CA。实际上，由于分布式系统中存在网络通信，而网络是不可靠的，一定会存在分区的情况，所以 CA 在实际生产中是永远不成立的。
![一致性、可用性、分区容忍性相互关系](http://pic.tanzhang.work/blog/20221228161311.png)

- **满足 CP 的情况**：分布式系统需要满足一致性和分区容忍性的时候，就会丢失一定的可用性。相当于在分布式系统中数据的同步时间被无限延长，为了保证请求得到正确结果，只能让系统暂时停止对外服务，选择 CP 的情况适用于对数据一致性要求比较高的场景，例如银行等涉及金钱交易的业务。
- **满足 AP 的情况**：满足 AP 的情况会使系统丢失一定的一致性，相当于在分布式系统存在网络分区期间，依然正常对外提供服务，而请求得到的数据跟预期数据并不一致。选择 AP 的情况适用于对数据一致性要求不是很高，而对可用性要求较高的场景。

分布式系统设计的目的就是为了保证服务的可用性。尽管“分布式事务”的目的就是如何保证分布式系统数据的一致性，但“一致性”却不得不成为被牺牲的一方，在节点数量庞大的分布式系统中，如果一味的去保证一致性，就会导致系统可用性降低，分布式系统设计的意义也就不存在了。不过，牺牲“一致性”不代表就完全不要一致性了，我们依然可以通过其他方法来保证数据的“最终一致性”。

## BASE 理论

BASE 是 Basically Available 基本可用、Soft State 软状态、Eventual Consistency 最终一致性 三者的缩写。BASE 理论指出在即使无法做到 强一致性，也可以通过某些合适的方法来达到最终一致性。

- 基本可用：分布式系统在出现故障时，允许损失部分可用性，保障核心服务可用；
- 软状态：分布式系统的软状态指的就是 CAP 定理中的数据不一致的状态；
- 最终一致性：分布式系统中的数据在经过一定时间以后，可以达到预期的状态；

BASE 理论实际上就是对 CAP 中 AP 模式的补充，当系统中产生网络分区时，保障系统的可用性，在此期间对数据的修改无法同步，导致数据的不一致性，此时的系统就处于软装态模式；当分区故障修复以后，系统中的数据继续进行同步，从而达到最终一致的状态。

## 二阶段提交（2PC）

分布式事务算法中比较有名的是“二阶段提交”，用来保证分布式系统中的强一致性。

在满足二阶段提交的分布式系统中，存在一个节点作为 协调者，其他节点 作为参与者，协调者和参与者的通信分为两个阶段，这也是二阶段提交的名称由来，其过程如下图所示：
![二阶段提交过程](http://pic.tanzhang.work/blog/20221229223437.png)

1. 准备提交阶段：协调者发起准备提交请求，参与者收到请求后首先完成准备提交的操作，这里的主准备提交操作，实际上是参与者将事务涉及到的数据修改都写入日志中，只是并不写入 commit record 记录，然后回复给协调者 prepared，如果写入失败则回复 non-prepared；（关于 commit record 如果不明白可以查看 [本地事务]() 篇）；
2. 提交阶段：如果准备提交阶段结束后协调者收到的反馈均为 prepared，提交阶段协调者将会发起提交请求，参与者接收到请求后，直接写入 commit record 记录，完成事务。如果任一参与者在准备提交阶段返回的是 non-prepared，则协调者会发起回滚请求，参与者接收到请求后，需要根据回滚日志删除已提交的数据。

不难看出，二阶段如果发起的是提交请求，这个操作是很轻量的，参与者只需写入一条日志；而如果发起的是回滚请求，参与者需要根据回滚日志删除数据，是负载相对较重的操作。

### 2PC成立的前提

二阶段提交的原理虽然简单，但是其成立需要具备两个前提条件：

一是网络可靠，在二阶段的提交阶段执行期间协调者发送的消息不会丢失或出错，如果是准备阶段出现网络问题，那协调者还可以发起回滚操作。而提交阶段由于事务已经完成处理（提交或回滚），丢失或收到错误消息的参与者将无法补救；

二是二阶段提交期间出现故障的节点最终将会恢复，不会远处于故障状态。由于准备阶段参与者已经写入所有的重做日志，故障恢复以后参与者可以去查询协调者事务执行状态，以此确定下一步是提交还是回滚操作。

### 2PC存在的问题

二阶段提交的原理虽然简单，但是存在一些明显的缺陷：

- 单点问题：在二阶段提交中，协调者可以具有超时机制，但参与者不可以，而协调者本身又是单点形式，如果在第二阶段协调者发生故障，没有正常发送 提交 或 回滚 命令，参与者将无法继续事务处理；
- 性能问题：二阶段提交执行过程中，所有参与者都是被绑定为一个整体，协调者和参与者间以同步的方式发送消息，如果参与者中有一个响应较慢，就会拖慢整个系统的处理速度；
- 状态不一致问题：二阶段提交成立的前提是网络可靠，如果网络不可靠导致部分消息丢失，部分参与者没有收到提交阶段的命令，则会导致数据不一致。

## 三阶段提交（3PC）

为了缓解二阶段提交的部分问题，又产生了三阶段提交，其过程如下所示：
![三阶段提交过程](http://pic.tanzhang.work/blog/20221229224402.png)

三阶段分为 canCommit、preCommit 和 doCommit 三阶段，实际上是在二阶段的基础上，增加了询问阶段，协调者让参与者根据自身情况，判断该事务是否能够顺利完成。

这样做的目的是因为 二阶段提交中的回滚操作是一个重负载操作，一旦协调者发起准备提交，参与者将开始写重做日志，所有涉及到的数据将被锁住，此时如果一个参与者宣告无法提交，那所有参与者相当于都做了一轮无用功。询问阶段的作用就是尽量确保在事务提交阶段能够正常提交，减小因为某个参与者无法提交而造成全部回滚的概率，在事务需要回滚的场景中，三阶段的性能通常是要比二阶段好很多的。

同样的，由于事务回滚的概率变小，当 preCommit 阶段完成后，如果协调者发生故障，参与者将在超时后自动将事务提交而不会回滚，这在一定程度上避免了二阶段中的单点故障问题。

### 三阶段缺点

三阶段提交在一定程度上缓解了二阶段的单点问题和回滚性能问题，但是却增加了一致性风险，如果在 preCommit 阶段，协调者发起的是回滚消息，而参与者并未全部收到消息，这部分未收到回滚消息的参与者在超时后将会自动提交事务，产生数据不一致问题。

另外，在事务都能够正常提交的场景中，三阶段的性能甚至不如二阶段提交，这是因为三阶段多了一个 询问阶段，多以此网络通信，性能自然比不上二阶段提交。
