---
title: 分布式事务常用方案调研
img: 'http://pic.tanzhang.work/blog/gallary/230101.jpg'
top: false
cover: false
toc: true
categories: 分布式
tags:
  - 事务
abbrlink: c5fea591
date: 2023-01-01 22:15:16
coverImg:
---
Base 理论将一致性划分出了 强一致性 和 最终一致性 的概念，基于这两种不同的一致性概念，产生了不同的分布式事务实现方案，比较常见的强一致性实现方案有 XA、AT 等；而最终一致性的常用方案有 TCC，SAGA 以及 可靠事件队列等。

## 强一致性方案

### DTP 与 XA

DTP 模型是 X/Open 组织提出的一套分布式事务模型，其主要组成部分分为三部分，分别如下：

- AP（Application Program）：指应用程序，可以理解为使用 DTP 的程序；
- RM（Resource Manager）：局部资源管理器，用于驱动本地事务，在程序中存在一个或多个；
- TM（Transaction Manager）：全局事务管理器，用于协调全局事务，在程序中只有一个；

TM 提供给了 AP 应用程序一套标准的 TX 协议，用于事务的 开启、提交或回滚。

RM、TM 为了完成分布式事务，需要进行通信，为了解决这个问题，DTP 模型定义了一套标准的 XA 通信接口。XA 接口是双向的，能在一个事务管理器和多个资源管理器之间形成通信桥梁，通过协调多个数据源之间的动作，实现全局事务的统一提交或回滚。

XA 事务模式的实现就是基于 DTP 模型，其原理就是 2PC，以 TM 来作为全局事务的协调者，而 RM 则是参与者，TM 通过 XA 通信接口向所有的 RM 发起 准备提交 或 提交 的请求，而 RM 也通过 XA 通信接口来向 TM 反馈执行结果:
![XA 事务工作过程](http://pic.tanzhang.work/blog/20230102163822.png)

由于 XA 事务是基于 2PC 来进行实现的，所以 2PC 存在的问题在 XA 中也基本存在，感兴趣的朋友可以阅读 [分布式事务基础理论]() 进行了解。

另外，XA 事务中还存在隔离性问题，事务在执行过程中，单个节点的数据有可能同时被其他事务修改，导致一致性问题。

### AT 事务模式

AT 模式是阿里 seata 提出的基于 XA 事务的改良版本，其核心原理依然是 2PC。AT 模式主要由3部分组成：

- TC（Transaction coordinator）：事务协调者，用于维护全局事务的状态，驱动全局事务提交或回滚；
- TM（Tansaction Manager）：事务管理器，定义全局事务的范围：开启、提交或回滚全局事务；
- RM（Resource Manager）：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

AT 模式的工作过程如下图所示：
![AT 事务工作过程](http://pic.tanzhang.work/blog/20230102171327.png)

首先由 TM 发起全局事务，RM 分支收到请求后，会先启动本地事务然后执行，并生成回滚记录；在本地事务提交前，RM 会先向 TC 注册事务分支，并申请对应的全局锁，拿到全局锁后，RM 会将分支事务提交，然后反馈给 TC 执行结果。当所有分支执行完毕后，TM 会再根据执行结果发起提交或回滚请求，由 TC 协调所有 RM 完成事务处理。

AT 事务相对于 XA 事务的优势在于全局锁的引入，由 AT 事务所修改的数据，都需要先向 TC 申请对应的全局锁才能提交，且拿到全局锁以后，会持续到全局事务提交以后才会释放，从这点上看，AT 事务通过全局锁避免了“脏写”的问题。

不过在读取的时候，AT 事务默认情况下并没有加任何锁，所以即使处于其他全局事务修改当中的数据，也可以被其他事务读取到，即实现的是“读未提交”隔离级别。

Seata 所实现 AT 事务模式在读取时也可以做额外处理，使读取时也获取到对应数据的全局锁。不过这种方式所获取的全局锁会增加锁冲突概率，阻塞其他事务对于对应数据的读写，导致数据写入和读取速率严重降低，并不推荐使用。

## 最终一致性方案

### 最大努力交付

最大可靠交付并不是最终一致性方案的具体实现方式，而是一种柔性事务思想，其原理如下图所示：
![最大可靠交付](http://pic.tanzhang.work/blog/20230102212835.png)

生产者完成本地事务以后，发送一条可靠消息给到消费者，消费者收到消息后激活对应的处理流程，完成事务处理，如果还有下一级处理，会继续发送可靠消息给到下一级。

最大可靠交付的核心思想在于消息这个环节，为了实现消息的可靠交付，衍生出了多种方案，如本地消息表，可靠事件队列。

#### 本地消息表

本地消息表故名思意，就是在每个节点中都建立一张消息表，将本地事务操作和写入消息的动作放在一个本地事务中，这样可以保证消息写入表和本地事务能够同时成功或失败。

消息写入后，通过远程调用的方式来触发下一个节点的业务处理，如果调用成功，则将本地消息的状态改为已完成；反之如果调用失败了也没关系，后续可以通过定时任务扫描消息表，然后根据消息表的日志再进行远程调用触发下一节点业务，成功之后再更新消息状态。

同一消息如果被重复发送，会导致服务之间的业务执行产生幂等性问题。解决这个问题的常用设计是让消息带上一个唯一的事务id，以保证同一事务中的业务操作只会执行一次。

同一任务的重复触发具有最大次数限制，超出之后可以通过告警的方式通知人工处理。

#### 可靠事件队列

可靠事件队列 与 本地消息 一样，其形式也是属于最大努力交付，只是实现方式略有不同。

可靠事件队列需要使用到消息队列来进行实现，为了保证消息的可靠性，就需要保证消费者在投递消息时，能够正确的投递到队列中，入队以后的消息永远不会丢失，以及消息在被消费以后，能够正确的被 ack 掉，保证业务操作的幂等性。

#### 最大努力交付的缺点

从实现方式上来看，最大努力交付在消息发出去以后，上游事务就是已经提交的状态，无法回滚，所以消息一但发出，不管中间是否有错误，事务最终只能是成功的，无法进行回滚。

另一方面，没有对数据做任何处理，所以
