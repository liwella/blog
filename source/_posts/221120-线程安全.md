---
title: 线程安全影响因素解析
author: 青蛙瓷器
img: 'http://pic.tanzhang.work/blog/gallary/221120.jpg'
top: false
cover: false
toc: true
mathjax: false
categories: 多线程
tags:
  - 线程安全
abbrlink: a98627d
date: 2022-11-20 10:19:00
coverImg:
---
线程可以共享进程范围内的资源，如内存句柄和文件句柄等，这并不意味着进程的所有资源都是共享的，每个线程有各自的程序计数器，栈以及局部变量等。线程提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，以提高复杂应用程序的性能。但是，由于线程可以共享进程的内存地址空间，如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程在访问某个变量时，另一个线程可能同时访问这个变量，造成不可预测的结果。影响线程安全的因素包括 **原子性、可见性和有序性。**

## 原子性

在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果，如下所示程序就可能会产生线程安全性问题：

```java
public class UnsafeSequence1 {
	private int value;
	// 每次调用都返回一个唯一的数值
	public int getNext() {
		return value++;
	}
}
```

在多线程环境下，上述程序并不能保证每次调用都获取到唯一的值。其原因在于 value++ 并非是原子的操作，可以将它分解为：读取 value，将 value 加 1，并将结果写入到 value。下图展示了出现错误的情况，当 thread1 执行完读取操作后，thread2 也执行读取操作，二者就会得到相同的结果：
![getNext()的错误执行情况](http://pic.tanzhang.work/blog/race_condition.png)

这是一种常见的并发安全问题，被称为竞态条件。在多线程环境下，竞态条件问题的出现取决于**运行时对线程中操作的交替执行方式**。上述问题中，如果 thread1 执行完所有操作之后，再切换到 thread2 执行读取操作，就不会出现错误。

如下程序展示了竞态条件的另一种常见形式时 “先检查后执行”，即通过一个可能失效的观测结果来决定下一步的动作：

```java
 public class UnsafeSequence2 {
	private int key = 0;
	private int value;
	// 判断当 key 等于 10 时，将 value 赋值为 20；
	public void setValue() {
		key++；
		if(key == 10) {
			value = 20;
			return;
		}
	}
}
```

当线程 A 判断 key 等于 10 后，切换到线程 B，线程 B 先执行了 key++，将 key 的值更新为 11，此时再次切换到线程 A，线程 A 认为 key 的值依然是 10（实际上 10 是一个失效值，正确的值是11），然后将 value 的值赋值为 20。

### synchronized

要避免静态条件问题，就必须将竞态条件涉及到的代码包裹起来，以原子的方式执行。Java 提供了一种内置锁的机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：：一个作为锁的对象引用，一个作为由这个锁保护的代码块。

以 synchronized 来修饰的方法就是一种横跨方法体的同步代码块，该代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class对象作为锁。除此之外，任何一个对象都可以用作一个实现同步的锁，线程在进入代码块之前会自动获得锁，而在退出代码块时自动释放锁。同一把锁在同一时刻只能由一个线程持有，这意味着只能有一个线程执行同步代码块中的代码，代码以“原子”的方式执行了。如下代码展示了以 synchronized 优化以后的 UnsafeSequence2：

```java
public class UnsafeSequence2 {
	private int key = 0;
	private int value;
	// 判断当 key 等于 10 时，将 value 赋值为 20；
	public synchronized void setValue() {
		key++；
		if(key == 10) {
			value = 20;
			return;
		}
	}
}
```

## 可见性

在处理运算任务时，计算机处理器需要与内存进行交互，如读取运算数据、存储运算结果等，这个 io 操作时很难消除的（无法仅靠寄存器来完成所有的运算任务）。由于处理器的运算速度与内存之间有着几个数量级的差距，如果处理器直接对内存进行读写，会拖慢处理器的运算速度。现代计算机系统为了解决这个问题，引入了一层或多层接近处理器运算速度的高速缓存来作为处理器和内存之间的缓冲。处理器在进行运算时，将需要使用的数据复制到高速缓存中，进行运算处理，处理完成后再从缓存中同步回内存中，这样就不需要等待缓慢的内存读写了。

基于高速缓存的存储交互很好的解决了处理器与内存之间速度的矛盾，但是也引入了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，由于得到的结果不一样，那同步回主内存时该以谁的缓存数据为准呢？为了解决这个问题，操作系统定义了一系列的一致性协议，在读写数据时需要遵循这些协议，来保证数据的一致性。
![处理器、高速缓存、主内存之间的交互关系](http://pic.tanzhang.work/blog/ram_model.png)

Java 的内存模型与操作系统类似，规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，保存了被该线程使用的变量的主内存副本。线程对变量的所有操作，都必须在工作内存中进行，不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。当一个线程先向某个变量写入一个值后，由于没来得及同步到主内存中，另一个线程读取这个变量，所得到的结果和上一个线程写入的不相同，这时就产生了线程安全中的可见性问题。
![线程、工作内存、主内存之间的交互关系](http://pic.tanzhang.work/blog/java_ram_model.png)

### volatile

关键字 volatile 是 java 提供的最轻量级的同步机制，它具备两项特性，一是可以保证被修饰的变量对所有线程的可见性，线程在使用该变量之前，会先刷新其在工作内存中的值，所以任何时候，线程看到该变量的值都是最新的。但volatile并不能保证原子性，代码中如果存在竞态条件，依然可能会产生并发问题。

## 有序性

编译器为了优化代码性能，有时候会改变代码的先后顺序，例如程序中“x=1；y=2”，在编译后有可能变为“y=2；x=1”，编译器调整了语句的顺序，但是并不影响程序的最终结果，不过编译器优化有时候可能会导致意想不到的bug。

```java
public class Singleton {
	static Singleton instance;
	static Singleton getInstance(){
		if (instance == null) {
			synchronized(Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

上述代码是懒汉式单例的典型实现方式，这段代码看上去没有任何问题，实际上却存在一定的安全隐患。编译器会对创建对象的 new 这个操作进行优化，正常情况下创建对象的执行过程顺序是这样的：

1. 分配一块内存 M；
2. 在内存 M 上创建 Singleton 对象；
3. 将内存 M 的地址赋值给 instance 变量；

但在编译器优化后的执行顺序却是这样的：

1. 分配一块内存 M；
2. 将内存 M 的地址赋值给 instance 变量；
3. 在内存 M 上创建 Singleton 对象；

按照这样的执行顺序可能会出现一个问题，当线程 A 调用 getInstance() 执行完步骤2以后，对象还没有被初始化完成，此时切换到线程B，线程B在调用 getInstance() 方法时，进入第一个判断 instance 不为 null，直接拿到尚未初始化的 instance，当线程 B 访问 instance 的成员变量时，由于还没有初始化完成，就会触发空指针异常。

关键字 volatile 的第二个特性就是可以禁止指令的重排序优化，保证变量的赋值操作与代码中的执行顺序一致。

## 总结

并发程序经常出现的诡异问题看起来非常难以理解，但仔细深究的话，无外乎是直觉欺骗了我们。只要能够深刻的理解原子性、可见性和有序性在并发场景下的原理，很多并发问题都是可以理解和诊断的。
