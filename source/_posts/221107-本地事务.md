---
title: 现代数据库事务实现原理
author: 青蛙瓷器
img: 'http://pic.tanzhang.work/blog/gallary/221107.jpg'
top: false
cover: true
toc: true
mathjax: false
categories: 数据库
tags:
  - 事务
abbrlink: 9d2ab52b
date: 2022-11-04 22:39:48
coverImg:
---
事务具有原子性、一致性、隔离性和持久性四大特性，其中隔离性又分为读已提交、读未提交、可重复读和串行化读；对于四大特性的理解，其实可以理解为原子性、隔离性和持久性是因，而一致性是果，即要实现一致性，就需要通过三个方面来进行保障：

- **原子性**：同一个事务对多个数据修改的操作是原子的，要么同时成功，要么同时失败；
- **持久性**：事务一旦提交，将持久化更新，不可更改；
- **隔离性**：多个事务之间是相互隔离的，相互之间不会有干扰；

## 原子性和持久性

原子性和持久性是两个密切相关的属性，原子性保证事务在操作多个数据的过程中，要么同时成功，要么同时失败；而持久性保证事务在执行完成后，就不会再有任何原因导致其修改的内容丢失或失效；

要实现事务的持久性，就需要在事务提交完成后，将事务在执行过程中修改到的数据，写入到磁盘中，以此保证数据不会丢失；而之所以原子性和持久性一起被提到，就是因为**数据写入磁盘的这个过程，并不是原子性的**；在数据写入磁盘的过程中，存在这写入和未写入等状态，如果在写入过程中，服务器宕机，则会使事务失去原子特性，甚至由于一部分数据未能正确写入到磁盘中，所以持久性也不能够得到保证；在没有额外策略来保障的情况下，事务提交可能会产生以下两种问题：

1. 事务提交前，写入后崩溃：假设当前事务操作了a，b，c三个数据，当事务尚未提交，事务对a的修改已经持久化到磁盘，但是b和c尚未写入到磁盘，此时服务器宕机，则数据的一致性得不到保障；
2. 事务提交后，写入前崩溃：同样假设事务操作了a，b，c三个数据，当事务提交后，事务对a的修改持久化到磁盘，然后数据库宕机，此时b和c的修改都尚未写入磁盘，也会导致事务失去一致性；

如果出现上述问题，为了保证事务的原子性和持久性，就只能通过手动补全数据的方式，来对事务进行修补，这种处理代价本身是极为昂贵的；

### commit logging

为了从根源上统一数据写入磁盘过程中状态问题，就不能在事务操作过程种逐个的去修改某一行或某一列的值，而是需要在事务提交后，一次性将内存中所有对数据的修改，写入到磁盘。实现这个操作的方式，是通过将对数据的修改，以顺序写的方式，写入到 **redo log** 日志当中，当**事务提交**后，再通过追加一条 事务提交成功 的提交记录 “commit record”，只有在事务成功提交“commit record”记录后，才会真正的去修改磁盘上的数据。当磁盘上数据修改完成后，会在日志中再追加一条“end record”，表示当前事务已经持久化完成，这种事务的处理方式被称为“commit logging”；

commit logging 的原理其实并不复杂，只有当事务成功的写入了“commit record”才代表事务提交成功，而后根据日志来将对数据修改应用到磁盘，这个过程中即使数据库的宕机，在后续恢复后，也可以根据日志继续对事务进行恢复。而如果数据库在事务成功写入“commit record”之前就宕机，那么整个事务就是失败的，数据库重启后发现这部分没有“commit record”的日志，并不会对其数据进行持久化，整个事务就好像没有发生过一样；

commit logging 确实很好的解决了原子性和持久性的问题，但是其带来了另外一个问题。由于仅能在日志写入“commit record”以后，才会将事务对数据的修改写入到磁盘中，在此之前，这些修改都是保存在内存中的，这就会导致如果事务修改的数据过多，占用的内存会过大；并且在写入“commit record”之前，即使磁盘是空闲的，数据也不会写入到磁盘，这对提升数据库的性能是十分不利的；

### write ahead logging

为了解决上述问题，又产生了一种新的解决方案，WAL（Write Ahead Logging），即在“commit record”之前，允许将对数据的修改写入到磁盘上，WAL根据何时写入数据到磁盘分为两种情况，force 和 steal：

- force：事务在提交的时候，必须将对数据的修改也全部写入到磁盘，称为force；反之称为 no-force；
- steal：事务在提交之前，可以将对数据的修改写入到磁盘，称为steal；反之称为 no-steal；

commit logging 是支持 no-force 的，但是其不支持 steal。而 WAL 在 commit logging 的基础上，支持了 steal，在事务执行期间，也可以将数据写入到磁盘，提高了磁盘的利用率，也减轻了内存的负担；

WAL 实现 steal 的方式时通过引入一种新 **undo log** 回滚日志，用于对事务回滚或数据库崩溃崩溃恢复时擦除已写入到磁盘上的数据，事务对数据的修改应用到磁盘之前，都需要先记录 undo log 日志。

数据库按照是否允许 force 和 steal 可以产生四种组合，从性能角度来说，no-force 和 steal 显然时性能最佳的。但是从实现角度来说，其也是最复杂的，因为需要同时引入 redo log 和 undo log 两种日志，下图展示了这四种组合与 undo log，redo log 之间的关系
![FROCE、STEAL的四种组合关系](http://pic.tanzhang.work/blog/force_steal.png)

## 隔离性的实现

现代数据库对事务提供了四种隔离级别，从低到高分别为：

- 读未提交：事务可以读取到其他事务尚未提交的数据，会产生脏读，即读取到的数据时无效的；
- 读已提交：事务可以读取到其他事务已经提交的数据，会产生不可重复读；
- 可重复读：事务执行过程中对同意个数据的读取结果总是一致的，会产生幻读；
- 串行化读：多个事务按照顺序依次执行，这个是最安全的隔离级别，当然性能也最低；

隔离性的主要目的时为了防止多个事务并发修改同一个数据，如果没有并发执行，即串行化执行，那事务之间就天然的具有隔离性。要实现事务之间的串行化执行，自然而然会想到需要对事务进行加锁，现代数据库提供了以下几种锁：

1. 写锁：也叫排他锁，当事务对数据进行修改时加上写锁，只有持有写锁的事务才能对数据进行修改，事务持有写锁时，其他事务不能加写锁，也不能加读锁；
2. 读锁：也称为共享锁，事务对数据进行读取时可以加上读锁，读锁与读锁之间互不冲突，与写锁之间则会产生冲突；
3. 间隙锁：写锁可以锁住某个数据，但是如果存在范围操作，则写锁不能将范围内的数据全部锁住；间隙锁的作用就是对范围进行上锁，防止范围内的数据被修改；

**串行化** 隔离级别的实现就是在事务进行数据读、写的过程中，同时加上读锁、写锁和间隙锁，以此来实现事务操作过程中其他事务不能够对数据进行任何操作；

但是串行化读的问题就是性能低下，由于缺少并发性，所以事务只能依次执行。由此有了比串行化读性能更优，但隔离性稍差的可重复读；**可重复读** 是在事务操作过程中，会加上读锁和写锁，但是不加间隙锁，读锁和写锁都会持续到事务结束；由于不加间隙锁，所以会产生幻读的问题，这里以一个例子来说明下什么是幻读：

假设学生表存在 name 和 age 两个字段，现在事务A要查询年龄是 5~10 岁年龄段内的学生，查询语句和查询结果如下：

```sql
A: start transaction
A：select name from student where age between 5 and 10; -- 查询结果为张三和李四
-- 此时事务B插入一条数据并提交：name：王五，age：7
A：select name from student where age between 5 and 10; -- 查询结果为张三、李四和王五，跟第一次查询结果不一样
A：commit;
```

以上例子说明了幻读的问题，由于在事务执行时不加入间隙锁，所以间隙内的数据在事务执行期间可能会被修改，导致两次查询到的结果不一致；当然，目前并不是所有数据库的可重复读都是按照这种方式来进行实现的，例如 Mysql 的可重复读隔离级别，是通过 MVVC 的方式来进行实现的，只有在当前读的情况下，才会产生幻读问题，由于篇幅问题，这里便不在继续展开讨论；

可重复读隔离级别的下一个隔离级别是 **读已提交**，和可重复读隔离级别一样，读已提交在进行数据读或写时也会加上读锁或写锁，但不同的是，读锁仅持续到查询结束后，就会释放，所以在读已提交隔离级别下，会产生不可重复读，同样以学生表为例，事务A有如下操作：

```sql
A：start transaction
A：select name from student where age = 5; -- 查询结果为张三
-- 事务A释放了读锁，此时事务B对 age=5 这条数据进行了修改并提交：name：李四，age：5
A：select name from student where age = 5; -- 此时发现查询结果变成了李四
A：commit;
```

从上述例子可以看出来，幻读和不可重复读的区别主要是在于，幻读是事务执行期间，其他事务对间隙内的数据进行了修改所致；而不可重复读是由于其他事务对已存在的数据进行了修改才会出现的；

读已提交下一个隔离级别是 **读未提交**，读未提交隔离级别下，事务在进行数据读取时，完全不加读锁，所以可以到其他事务还没有提交的数据；

理论上还存在比读未提交隔离级别更低的隔离级别，即事务读、写过程中，读写锁都不加，由于不加写锁，所以事务是可以并发对数据进行修改的，这就会产生“脏写”的问题，脏写问题已经不仅仅是隔离性上的问题了，当产生脏写问题时，甚至连数据的原子性都得不到保证，所以这种隔离级别是完全没有意义的，这里就不在做过多讨论。
